-------------------------------------------------------------------------------
-- Current implementation of forest mod (June 2025)
-------------------------------------------------------------------------------
function migrateTreeMesh(mesh)
    if string.sub(mesh, 1, 5) == "tree_" then
        mesh = "SM_Conifer_03"
    end
    return mesh
end
-------------------------------------------------------------------------------
function tokenizeForestPart(str)
    local tokens = {}
    for token in str:gmatch("[^,]+") do
        table.insert(tokens, token:match("^%s*(.-)%s*$")) -- trim whitespace
    end
    return {
        mesh = migrateTreeMesh(tokens[1]),
        x = tonumber(tokens[2]) or 0,
        y = tonumber(tokens[3]) or 0,
        z = tonumber(tokens[4]) or 0,
        rotation = tonumber(tokens[5]) or 0,
        age = tonumber(tokens[6]) or 0,
        health = tonumber(tokens[7]) or 0
    }
end
-------------------------------------------------------------------------------
function calculateTreeMeshByAge(mesh,age)

    local number = tonumber(mesh:match("^SM_Conifer_(%d+)$"))

    if math.floor(age / 8000) > number then
        number = number + 1
    end

    if number > 3 then number = 3 end

    return string.format("SM_Conifer_%02d", number)
end
-------------------------------------------------------------------------------
function distance3D(v1, v2)
    local dx = v2[1] - v1[1]
    local dy = v2[2] - v1[2]
    local dz = v2[3] - v1[3]
    return math.sqrt(dx * dx + dy * dy + dz * dz)
end
-------------------------------------------------------------------------------
-- Will attempt 100 times to find a suitable nearby position for a new
-- sapling spawn. Will consider Z axis to avoid spawning things in the air.
-- 
function findEmptyLocationNear(forest)
        
    local coords = WorldItems.GetCoords(forest)

    for pos = 1, 100 do
        local newX = coords.x + (math.random(6000) - 3000)
        local newY = coords.y + (math.random(6000) - 3000)
        local newZ = Game.GroundAt(newX, newY, coords.z)

        if math.abs(newZ - z) < 20 then
            nearest = WorldItems.NearestAt(newX, newY, newZ)
            if nearest ~= nil then
                distance = distance3D( {coords.x, coords.y, coords.z}, {newX, newY, newZ} )
                if distance > 300 then
                    if pos > 1 then
                        Game.Print("new forest tree took " .. pos .. " attempts")
                    end

                    Game.Print(string.format("New location: /debugdot %.0f,%.0f,%.0f",
                        newX, newY, newZ))

                    return true, newX, newY, newZ
                end
            end
        end
    end

    Game.Print("Warning: could not find suitable location to new forest tree")
    return false,0,0,0
end
-------------------------------------------------------------------------------
function destroyTreeAt(forest,coords)

    Debug.DrawSphere(coords.x,coords.y,coords.z, 200)

    Game.Print("Destroy tree at called:" .. forest)
    trees = WorldItems.Get(forest, "trees")
    base_coords = WorldItems.GetCoords(forest)

    Game.Print(string.format("WORLDITEM %s = %f,%f,%f", forest,base_coords.x,base_coords.y,base_coords.z))

    if trees then
        for treePos, treeString in ipairs(trees) do
            tree = tokenizeForestPart(treeString)

            distance = distance3D( {coords.x, coords.y, 0}, {tree.x + base_coords.x, tree.y + base_coords.y, 0} )
                
            if distance < 1100 then

                Game.Print(string.format("%f,%f to %f,%f distance = %f...", coords.x,coords.y,tree.x,tree.y,distance))

                -- Debug.DrawSphere(tree.x,tree.y,tree.z, 200)
                Debug.DrawLine(coords.x,coords.y,coords.z,
                                base_coords.x + tree.x,
                                base_coords.y + tree.y,
                                base_coords.z + tree.z)

            --     Game.Print(string.format("Found tree at %d cm, destroying...", distance))
            --     -- table.remove(trees, treePos)
            --     -- WorldItems.Set(forest, "trees", trees)
            --     -- WorldItems.DestroyMeshAt(forest,tree.x,tree.y,tree.z)
            --     -- return true
            end
            
        end
    end

    return false
end
-------------------------------------------------------------------------------
WorldItems.ReactsTo("forest", Events.OnItemUse,
function(player,inventory_guid,class)
    x,y,z = Game.InFrontOf(player,100,0)
    if Inventory.RemoveFrom(player,inventory_guid) then
        newForest = WorldItems.SpawnItemAt("forest",x,y,z,math.random(360))
        
        WorldItems.AddMeshTo(newForest, "SM_Conifer_01",0,0,0,0) 
        newTreeTable = {}
        table.insert(newTreeTable, "SM_Conifer_01,0,0,0,0,0,100")
        WorldItems.Set(newForest, "trees", newTreeTable)
    end
end)
-------------------------------------------------------------------------------
WorldItems.ReactsTo("forest", Events.OnLoad, 
function(forest)
    trees = WorldItems.Get(forest, "trees")
    if trees then
        for _, treeString in ipairs(trees) do
            tree = tokenizeForestPart(treeString)
            mesh = calculateTreeMeshByAge(tree.mesh, tree.age)

            -- Game.Print(string.format("Loading forest tree:%s at %.0f,%.0f,%.0f",
            --     mesh,tree.x,tree.y,tree.z))

            WorldItems.AddMeshTo(forest,mesh,tree.x,tree.y,tree.z,tree.rotation)
        end
    end
end)
-------------------------------------------------------------------------------
function OnFinishedChoppingTree(player, forest, coords)

    if destroyTreeAt(forest,coords) then
        Inventory.AddTo(player,"lumber")
    else
        Players.FlashMessage(player, "No lumber was obtained.")
    end

end
-------------------------------------------------------------------------------
WorldItems.ReactsTo("forest", Events.OnClick, 
function(player,forest,coords)

    options = {}
    -------------------------------------------------------
    table.insert(options, {"Chop Tree", function(player,forest) 

        Players.MoveTo(player, coords, {

            acceptance_radius = 50,
            on_completed = function(player)
                
                Players.Action(player,"chopping_tree", 1, {
                    interruptable = true,
                    on_completed = function(player)

                        OnFinishedChoppingTree(player, forest, coords)

                    end
                } )
            end
        })

    end })
    -------------------------------------------------------
    Game.Menu(player,forest,options)
end)
-------------------------------------------------------------------------------
WorldItems.ReactsTo("forest", Events.OnEveryMinute, 
function()

    local count = WorldItems.Count("forest")
    for pos = 1, count do
        local forest = WorldItems.At("forest", pos)
        local trees = WorldItems.Get(forest, "trees")
        local newTreeTable = {}
        
        -- Increase age of each tree
        for _,treeString in ipairs(trees) do
            local tree = tokenizeForestPart(treeString)
            tree.age = tree.age + math.random(3)
            local oldMesh = tree.mesh
            local calculatedMesh = calculateTreeMeshByAge(tree.mesh, tree.age)
            new_tree = string.format("%s,%.0f,%.0f,%.0f,%.0f,%d,%d",
                calculatedMesh,
                tree.x,
                tree.y,
                tree.z,
                tree.rotation,
                tree.age,
                tree.health)
            table.insert(newTreeTable,new_tree)

            -- Update tree mesh if changed
            if oldMesh ~= calculatedMesh then
                -- Game.Print(string.format("Replacing tree mesh:%s for %s", oldMesh, calculatedMesh))
                WorldItems.ReplaceMeshAt(forest, 
                    calculatedMesh,
                    tree.x,tree.y,tree.z,tree.rotation)
            end
        end

        -- Spawn saplings
        if math.random(3600) < 10 and #trees < 30 then

            Game.Print("Attempting to spawn a new sapling")
            local valid,newX,newY,newZ = findEmptyLocationNear(forest)
            if valid then
                local coords = WorldItems.GetCoords(forest)
                newX = newX - coords.x
                newY = newY - coords.y
                newZ = newZ - coords.z
                local newRotation = math.random(360)
                local new_sapling = string.format(
                    "SM_Conifer_01,%.0f,%.0f,%.0f,%.0f,%d,%d",
                    newX,
                    newY,
                    newZ,
                    newRotation,
                    0,
                    100)
                Game.Print("new sapling:" .. new_sapling)
                table.insert(newTreeTable,new_sapling)
                WorldItems.AddMeshTo(forest,"SM_Conifer_01",newX,newY,newZ,newRotation)
            end
        end

        WorldItems.Set(forest, "trees", newTreeTable)

    end
end)
